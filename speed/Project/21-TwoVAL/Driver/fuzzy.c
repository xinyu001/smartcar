#include "include.h"
extern float  Delta_P;
extern float  Delta_D;



void Fuzzy(float P,float D)
{
/*输入量P语言值特征点*/ 
float PFF[7]={-16,-10,-5,0,5,10,16};
/*输入量D语言值特征点*/ 
float DFF[5]={-12,-6,0,6,12};
/*输出量P语言值特征点(根据赛道类型选择不同的输出值)*/
float UPF[7]={0,1,2,3,4,5,6};
/*输出量D语言值特征点(根据赛道类型选择不同的输出值)*/
float UDF[5]={0,0.1,0.3,0.5,1};

int rule_P[7][5]={
//  -2  -1   0   1   2 ec    e
  { 4,  5,  5,  0,  0}, //  -3     { 4,  5,  5,  0,  0}, //  -3      { 4,  5,  5,  0,  0}, //  -3 
  { 3,  4,  4,  0,  0}, //  -2     { 3,  4,  4,  0,  0}, //  -2      { 5,  4,  4,  0,  0}, //  -2  
  { 3,  3,  4,  0,  0}, //  -1     { 3,  3,  4,  0,  0}, //  -1      { 2,  2,  1,  0,  0}, //  -1  
  { 2,  1,  0,  1,  2}, //   0     { 2,  1,  0,  1,  2}, //   0      { 2,  1,  0,  1,  2}, //   0  
  { 0,  0,  4,  3,  3}, //   1     { 0,  0,  4,  3,  3}, //   1      { 0,  0,  1,  2,  2}, //   1  
  { 0,  0,  4,  4,  3}, //   2     { 0,  0,  4,  4,  3}, //   2      { 0,  0,  4,  4,  5}, //   2  
  { 0,  0,  5,  5,  4}  //   3     { 0,  0,  5,  5,  4}  //   3      { 0,  0,  5,  5,  5}  //   3  
};

int rule_D[7][5]={
//  -2  -1   0   1   2 ec    e
  { 0,  0,  0,  0,  0}, //  -3
  { 0,  0,  0,  0,  0}, //  -2
  { 4,  3,  2,  0,  0}, //  -1
  { 4,  4,  4,  4,  4}, //   0
  { 0,  0,  2,  3,  4}, //   1
  { 0,  0,  0,  0,  0}, //   2
  { 0,  0,  0,  0,  0}  //   3
};

//int rule_S[7][5]={
////  -2  -1   0   1   2 ec    e
//  { 0,  0,  0,  0,  0}, //  -3
//  { 0,  0,  0,  0,  0}, //  -2
//  { 4,  3,  2,  0,  0}, //  -1
//  { 4,  4,  4,  4,  4}, //   0
//  { 0,  0,  2,  3,  4}, //   1
//  { 0,  0,  0,  0,  0}, //   2
//  { 0,  0,  0,  0,  0}  //   3
//};


float PF[2]={0},DF[2]={0};
 /*偏差,偏差微分以及输出值的隶属度*/ 
int Pn=0,Dn=0,Un[2]={0};
/*隶属度的确定*/ 
/*根据PD的指定语言值获得有效隶属度*/ 
 if(P>PFF[0] && P<PFF[6])
{
 if(P<=PFF[1])
 {
  Pn=-2;
  PF[0]=(PFF[1]-P)/(PFF[1]-PFF[0]);//值越小越接近右侧
 }
 else if(P<=PFF[2])
 {
  Pn=-1;
  PF[0]=(PFF[2]-P)/(PFF[2]-PFF[1]);
 }
 else if(P<=PFF[3])
 {
  Pn=0;
  PF[0]=(PFF[3]-P)/(PFF[3]-PFF[2]);
 }
 else if(P<=PFF[4])
 {
  Pn=1;
  PF[0]=(PFF[4]-P)/(PFF[4]-PFF[3]);
 }
 else if(P<=PFF[5])
 {
  Pn=2;
  PF[0]=(PFF[5]-P)/(PFF[5]-PFF[4]);
 }
 else if(P<=PFF[6])
 {
  Pn=3;
  PF[0]=(PFF[6]-P)/(PFF[6]-PFF[5]);
 }
}
 
 else if(P<=PFF[0])
 {
  Pn=-2;
  PF[0]=1;
 }
 else if(P>=PFF[6])
 {
  Pn=3;
  PF[0]=0;
 }

PF[1]=1-PF[0];


//判断D的隶属度
 if(D>DFF[0]&&D<DFF[4])
 {
  if(D<=DFF[1])
  {
   Dn=-2;
   DF[0]=(DFF[1]-D)/(DFF[1]-DFF[0]);//值越小越接近右侧
  }
 else if(D<=DFF[2])
 {
  Dn=-1;
  DF[0]=(DFF[2]-D)/(DFF[2]-DFF[1]);
  }
 else if(D<=DFF[3])
 {
  Dn=0;
  DF[0]=(DFF[3]-D)/(DFF[3]-DFF[2]);
  }
 else if(D<=DFF[4])
 {
  Dn=1;
  DF[0]=(DFF[4]-D)/(DFF[4]-DFF[3]);
 }
 }
 //不在给定的区间内
 else if (D<=DFF[0])
 {
  Dn=-2;
  DF[0]=1;
 }
 else if(D>=DFF[4])
 {
  Dn=1;
  DF[0]=0;
 }

DF[1]=1-DF[0];

if(PF[0]>0.5)
{
   Pn=Pn-1;
}

if(DF[0]<=0.5)
{
   Dn=Dn+1;
}

Un[0]=rule_P[Pn+3][Dn+2];
Un[1]=rule_D[Pn+3][Dn+2];

Delta_P=UPF[Un[0]];
Delta_D=UDF[Un[1]];
}